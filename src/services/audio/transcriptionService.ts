import { supabase } from '@/integrations/supabase/client';
import { TranscriptionResult } from './types';
import { toast } from 'sonner';

/**
 * Transcribes an audio file using the OpenAI Whisper API
 * @param audioUrl The URL of the audio file to transcribe
 * @returns The transcription result
 */
export const transcribeAudio = async (audioUrl: string): Promise<TranscriptionResult> => {
  try {
    console.log('Starting transcription process for:', audioUrl);
    
    // Ensure user is authenticated
    const { data: sessionData, error: sessionError } = await supabase.auth.getSession();
    
    if (sessionError || !sessionData.session) {
      throw new Error('Authentication error. Please log in again.');
    }
    
    // For simulation mode, if we don't need to actually call the API
    const isSimulation = audioUrl.includes('simulation-recording');
    
    let transcriptionResult: TranscriptionResult;
    
    if (isSimulation) {
      transcriptionResult = await handleSimulationMode();
    } else {
      transcriptionResult = await processRealTranscription(audioUrl, sessionData.session.access_token);
    }
    
    // Update the transcription record with the transcribed text and duration
    await updateTranscriptionRecord(audioUrl, transcriptionResult, sessionData.session.user.id);
    
    console.log('Transcription record updated with text:', transcriptionResult.text.substring(0, 50) + '...');
    
    return transcriptionResult;
  } catch (error) {
    console.error('Error transcribing audio:', error);
    throw error;
  }
};

/**
 * Handles simulation mode for testing without actual API calls
 */
const handleSimulationMode = async (): Promise<TranscriptionResult> => {
  console.log('Detected simulation mode, generating mock transcription');
  
  // Create a simulated transcription result
  const transcriptionResult: TranscriptionResult = {
    text: "This is a simulated transcription. In a real scenario, this text would be generated by processing your audio file with OpenAI's Whisper API.",
    duration: 15.5,
    language: 'en'
  };
  
  // Add a slight delay to simulate API call
  await new Promise(resolve => setTimeout(resolve, 1500));
  
  return transcriptionResult;
};

/**
 * Processes an actual transcription request via the edge function
 */
const processRealTranscription = async (audioUrl: string, accessToken: string): Promise<TranscriptionResult> => {
  console.log('Calling OpenAI Whisper API via edge function');
  
  // Add a short delay to ensure the file is available
  await new Promise(resolve => setTimeout(resolve, 2000));
  
  // Initialize transcription attempt with improved retry handling
  const maxAttempts = 5; // Increased from 3 to 5
  const baseRetryDelay = 3000; // 3 seconds
  
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      console.log(`Transcription attempt ${attempt}/${maxAttempts} for URL: ${audioUrl}`);
      
      const { data, error } = await supabase.functions.invoke('openai-whisper', {
        body: { audioUrl },
        headers: {
          Authorization: `Bearer ${accessToken}`
        }
      });
      
      if (error) {
        console.error(`Transcription attempt ${attempt} failed:`, error);
        
        if (attempt === maxAttempts) {
          throw new Error(`Edge function error: ${error.message}`);
        }
        
        // Wait with exponential backoff before retrying
        const retryDelay = baseRetryDelay * Math.pow(2, attempt - 1);
        console.log(`Retrying in ${retryDelay}ms...`);
        await new Promise(resolve => setTimeout(resolve, retryDelay));
        continue;
      }
      
      if (!data) {
        throw new Error('No data returned from transcription API');
      }
      
      if (data.error) {
        throw new Error(`API error: ${data.error}`);
      }
      
      // Validate the response contains the expected data
      if (!data.transcription) {
        throw new Error('Transcription data is missing from API response');
      }
      
      return {
        text: data.transcription,
        duration: data.duration || 0,
        language: data.language || 'en'
      };
    } catch (attemptError) {
      if (attempt === maxAttempts) {
        throw attemptError;
      }
      // Continue to the next iteration for retry
    }
  }
  
  // This should never be reached due to throw in the loop, but TypeScript requires a return
  throw new Error('Failed to transcribe audio after multiple attempts');
};

/**
 * Updates the transcription record in the database
 */
const updateTranscriptionRecord = async (
  audioUrl: string, 
  transcriptionResult: TranscriptionResult, 
  userId: string
): Promise<void> => {
  console.log('Updating transcription record in database');
  
  try {
    // Build the update object with only fields we know exist
    const updateData: Record<string, any> = { 
      text: transcriptionResult.text,
      status: 'completed',
      completed_at: new Date().toISOString()
    };
    
    // Only add optional fields if they exist
    if (transcriptionResult.duration !== undefined) {
      updateData.duration = transcriptionResult.duration;
    }
    
    if (transcriptionResult.language) {
      updateData.language = transcriptionResult.language;
    }
    
    const { error: updateError } = await supabase
      .from('transcriptions')
      .update(updateData)
      .eq('audio_url', audioUrl)
      .eq('user_id', userId);
        
    if (updateError) {
      // Check if error is about missing columns and try without optional fields
      if (updateError.message.includes('column') && updateError.message.includes('does not exist')) {
        console.warn('Column missing in transcriptions table:', updateError.message);
        
        const fallbackUpdateData = { 
          text: transcriptionResult.text,
          status: 'completed',
          completed_at: new Date().toISOString()
        };
        
        const { error: fallbackError } = await supabase
          .from('transcriptions')
          .update(fallbackUpdateData)
          .eq('audio_url', audioUrl)
          .eq('user_id', userId);
          
        if (fallbackError) {
          throw fallbackError;
        }
      } else {
        throw updateError;
      }
    }
  } catch (error) {
    console.error('Error updating transcription record:', error);
    throw new Error(`Failed to update transcription: ${error.message}`);
  }
};
